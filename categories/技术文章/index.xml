<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术文章 on Present Day, Present Time</title>
    <link>https://gobomb.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/</link>
    <description>Recent content in 技术文章 on Present Day, Present Time</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 17 Dec 2018 02:08:25 +0800</lastBuildDate>
    
	<atom:link href="https://gobomb.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ngrok 1.X 源码解析(WIP)</title>
      <link>https://gobomb.github.io/post/ngrok-1.x-sourccode-reading/</link>
      <pubDate>Mon, 17 Dec 2018 02:08:25 +0800</pubDate>
      
      <guid>https://gobomb.github.io/post/ngrok-1.x-sourccode-reading/</guid>
      <description>背景 ngrok是我第一次接触的 go 项目，也是我第一个完整阅读过源码的开源项目。一开始读代码我还是 go 语言零基础，只写过一点点 Web 后端 API，读了好</description>
    </item>
    
    <item>
      <title>编程语言的求值策略</title>
      <link>https://gobomb.github.io/post/evaluation_strategy/</link>
      <pubDate>Thu, 25 Jan 2018 17:09:03 +0800</pubDate>
      
      <guid>https://gobomb.github.io/post/evaluation_strategy/</guid>
      <description>在面试的时候遇到一个问题：“golang 的传参是按值传递还是按引用传递？”我第一反应是 go 在很多场景下传参和赋值都会发生内存的复制，同时记得 go</description>
    </item>
    
    <item>
      <title>并发模型比较</title>
      <link>https://gobomb.github.io/post/high-concurrency-model/</link>
      <pubDate>Sat, 25 Nov 2017 22:13:27 +0800</pubDate>
      
      <guid>https://gobomb.github.io/post/high-concurrency-model/</guid>
      <description>Go 的特色之一就是 goroutine ，使得程序员进行并发编程更加方便，适合用来进行服务器编程。作为后端开发工程师，有必要了解并发编程面临的场景和常见的解决方案</description>
    </item>
    
  </channel>
</rss>