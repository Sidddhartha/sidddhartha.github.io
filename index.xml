<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cym&#39;s blog</title>
    <link>https://gobomb.github.io/</link>
    <description>Recent content on Cym&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 29 Dec 2017 17:17:27 +0800</lastBuildDate>
    
	<atom:link href="https://gobomb.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>交叉编译 V2Ray</title>
      <link>https://gobomb.github.io/post/cross-complie-v2ray/</link>
      <pubDate>Fri, 29 Dec 2017 17:17:27 +0800</pubDate>
      
      <guid>https://gobomb.github.io/post/cross-complie-v2ray/</guid>
      <description>问题和背景 朋友想在路由器里跑 V2Ray，但官方 release 版本不能用，拜托我重新编译一份可执行文件。该路由器没有 FPU（Float Point Unit，浮点运算</description>
    </item>
    
    <item>
      <title>Links</title>
      <link>https://gobomb.github.io/links/</link>
      <pubDate>Sun, 26 Nov 2017 22:20:05 +0800</pubDate>
      
      <guid>https://gobomb.github.io/links/</guid>
      <description> Links ckyOL&amp;rsquo;s b10g https://blog.ckyol.moe/ </description>
    </item>
    
    <item>
      <title>多种高并发模型比较</title>
      <link>https://gobomb.github.io/post/high-concurrency-model/</link>
      <pubDate>Sat, 25 Nov 2017 22:13:27 +0800</pubDate>
      
      <guid>https://gobomb.github.io/post/high-concurrency-model/</guid>
      <description>Golang 的特色之一就是 goroutine ，使得程序员进行并发编程更加方便，适合用来进行服务器编程。作为后端开发工程师，有必要了解并发编程面临的场景和常见的解决方案</description>
    </item>
    
    <item>
      <title>如何用 Golang 写单元测试</title>
      <link>https://gobomb.github.io/post/how-to-write-unit-testing-in-golang/</link>
      <pubDate>Mon, 06 Nov 2017 16:52:19 +0800</pubDate>
      
      <guid>https://gobomb.github.io/post/how-to-write-unit-testing-in-golang/</guid>
      <description>为什么要写单元测试 以前写程序的时候，一般不写测试，阅读开源代码遇到测试也都是跳过不读。调试的时候一半都是手动输入测试数据，在代码里打印 log 信息</description>
    </item>
    
    <item>
      <title>用 Hugo 和 GitHub Page 搭建博客</title>
      <link>https://gobomb.github.io/post/make-a-blog-by-hugo-and-github-page/</link>
      <pubDate>Tue, 31 Oct 2017 16:02:19 +0800</pubDate>
      
      <guid>https://gobomb.github.io/post/make-a-blog-by-hugo-and-github-page/</guid>
      <description>图省事，懒得花钱买域名和备案，就用 GitHub Page 来搭博客了。 hugo 是用 Golang 写的静态网站生成器。支持 Markdown 语法。 另一个用js写的同类工具jekyll 比较出名。 安装</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://gobomb.github.io/about/</link>
      <pubDate>Tue, 31 Oct 2017 14:37:01 +0800</pubDate>
      
      <guid>https://gobomb.github.io/about/</guid>
      <description>About Me 深圳大学 / 计算机与软件学院 / 软件工程专业 / 大四学生 Golang / 后端 学习中 GitHub：https://github.com/gobomb 技术笔记</description>
    </item>
    
    <item>
      <title></title>
      <link>https://gobomb.github.io/essay/go-type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gobomb.github.io/essay/go-type/</guid>
      <description>类型系统和类型 类型的概念 变量就是一段或多段用来存储数据的内存，类型则规定了变量内存的长度和存储格式。类型系统可以理解成为 一种约定，约定程序员和计算机要怎么操作和存储数据。不同的编程语言有不同的类型系统。语言特性的不同都是 因为具体需求和应用场景的不同，适合的就是好的。大致上，可以用强/弱类型和静态/动态类型来作一个划分。
什么是强类型呢？就是当一个变量确定了类型，除非强制进行类型转换，不然不能够改变其类型， 反之，弱类型就是变量可以不指定类型，或允许隐式转换，如 C 语言和 JavaScript。强类型语言对类型 检查要求比较严谨，需要程序员在编程的时候明确不同类型的区别；而弱类型优点在于更加灵活，缺点是容易 出错。如 C 有许多“黑魔法”，可以用指针直接指向一块内存。
强弱类型的概念并没有特别严格的定义，只能说程度上有差异。
而静态类型与动态类型的区别在于，前者在编译期就执行类型检查，后者在运行期执行类型检查。 前者的代表为 Java / C#，后者的例子是 Python 等大部分脚本语言。静态类型执行起来会比较快，便于调试， 相对而言，动态语言效率就没那么高，运行时开销比较大。
在 Go 中，所有的类型转换都要显式声明。其实拥有相同底层结构的不同类型，也需要显式转换。 如在 64 位平台上，int 和 int64 都是 8 字节整型，不显式转换的话编译器会报错。
go 使用 unsafe 包进行类型转换 go 进行类型转换和字符串拼接时，有时候会引发内存复制，重新分配内存，如果对性能有要求的话，大量的内存复制会拖慢性能。
可使用非安全的指针类型转换来实现类型变更，避免内存复制。
https://zhuanlan.zhihu.com/p/31765927 https://zhuanlan.zhihu.com/p/20010926</description>
    </item>
    
    <item>
      <title></title>
      <link>https://gobomb.github.io/essay/why-nosql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gobomb.github.io/essay/why-nosql/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>